---
layout: default
title: Elijah Hauber's Works
---
	<h1>{{ page.title }}</h1>
	<h3>Games</h3>
	<div style="display: flex; gap: 2rem; flex-wrap: wrap; margin-bottom: 2rem;">
		<a href="../games/pong" style="text-align: center; text-decoration: none; color: inherit; border: 1px solid #ccc; border-radius: 8px; padding: 1rem; width: 180px; box-shadow: 2px 2px 8px #eee; transition: box-shadow 0.2s; background: #faf9f6;">
			<img src="/assets/pong.png" alt="Pong Game" style="width: 100%; height: 120px; object-fit: contain; margin-bottom: 0.5rem;" loading="lazy">
			<div style="font-size: 1.2rem; font-weight: bold;">Pong</div>
		</a>
		<a href="../games/flappy" style="text-align: center; text-decoration: none; color: inherit; border: 1px solid #ccc; border-radius: 8px; padding: 1rem; width: 180px; box-shadow: 2px 2px 8px #eee; transition: box-shadow 0.2s; background: #faf9f6;">
			<img src="/assets/flappy.png" alt="Flappy Flyer Game" style="width: 100%; height: 120px; object-fit: contain; margin-bottom: 0.5rem;" loading="lazy">
			<div style="font-size: 1.2rem; font-weight: bold;">Flappy Flyer</div>
		</a>
	</div>

	<div style="display: flex; gap: 3rem; flex-wrap: wrap; justify-content: center;">
		<div style="text-align: center;">
			<h3 style="margin-bottom: 1rem;">Mandelbrot Set</h3>
			<div style="position: relative; display: inline-block; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
				<canvas id="myCanvas" width="600" height="600" class="img-fluid" style="display: block; background: #f8f9fa;"></canvas>
				<div id="mandelbrotLoader" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(248, 249, 250, 0.95); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(2px);">
					<div style="text-align: center; padding: 2rem;">
						<div style="width: 60px; height: 60px; border: 4px solid #e9ecef; border-top: 4px solid #fbdc75; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
						<div style="font-size: 1.1rem; color: #495057; font-weight: 500;">Rendering Mandelbrot Set...</div>
						<div id="mandelbrotProgress" style="margin-top: 0.5rem; font-size: 0.9rem; color: #6c757d;">Initializing...</div>
					</div>
				</div>
			</div>
		</div>

		<div style="text-align: center;">
			<h3 style="margin-bottom: 1rem;">Julia Set</h3>
			<div style="position: relative; display: inline-block; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
				<canvas id="juliaCanvas" width="600" height="600" class="img-fluid" style="display: block; background: #f8f9fa;"></canvas>
				<div id="juliaLoader" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(248, 249, 250, 0.95); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(2px);">
					<div style="text-align: center; padding: 2rem;">
						<div style="width: 60px; height: 60px; border: 4px solid #e9ecef; border-top: 4px solid #fbdc75; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
						<div style="font-size: 1.1rem; color: #495057; font-weight: 500;">Rendering Julia Set...</div>
						<div id="juliaProgress" style="margin-top: 0.5rem; font-size: 0.9rem; color: #6c757d;">Initializing...</div>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div style="text-align: center; margin-top: 2rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; color: #6c757d;">
		<small>
			<strong>Mathematical Art:</strong> These fractals are generated in real-time using complex mathematical algorithms. 
			The Mandelbrot set explores the boundary of chaos, while the Julia set reveals intricate patterns through iterative functions.
		</small>
	</div>

	<style>
		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}
		
		@keyframes fadeIn {
			from { opacity: 0; transform: translateY(20px); }
			to { opacity: 1; transform: translateY(0); }
		}
		
		.fractal-container {
			animation: fadeIn 0.6s ease-out;
		}
		
		canvas {
			transition: opacity 0.3s ease;
		}
		
		@media (max-width: 768px) {
			canvas {
				width: 100% !important;
				height: auto !important;
				max-width: 400px;
			}
		}
	</style>

	<script>
	// Enhanced fractal renderer with better UX
	class FractalRenderer {
		constructor() {
			this.isRendering = false;
		}

		async renderMandelbrot(canvas, progressCallback) {
			if (this.isRendering) return;
			this.isRendering = true;
			
			const ctx = canvas.getContext('2d');
			const width = canvas.width;
			const height = canvas.height;
			
			const magnificationFactor = 200;
			const panX = 2;
			const panY = 1.5;
			const iterations = 100;
			
			// Clear canvas with a subtle background
			ctx.fillStyle = '#f8f9fa';
			ctx.fillRect(0, 0, width, height);
			
			// Process in chunks with better progress tracking
			const chunkSize = 8000;
			let pixelCount = 0;
			const totalPixels = width * height;
			
			for (let x = 0; x < width; x++) {
				for (let y = 0; y < height; y++) {
					const belongsToSet = this.checkIfBelongsToMandelbrotSet(
						x / magnificationFactor - panX,
						y / magnificationFactor - panY,
						iterations
					);
					
					if (belongsToSet === 0) {
						ctx.fillStyle = '#fbdc75';
						ctx.fillRect(x, y, 1, 1);
					} else {
						ctx.fillStyle = `hsl(261, 80%, ${Math.abs(belongsToSet - 100)}%)`;
						ctx.fillRect(x, y, 1, 1);
					}
					
					pixelCount++;
					
					// Update progress more frequently for better UX
					if (pixelCount % chunkSize === 0) {
						const progress = pixelCount / totalPixels;
						progressCallback(progress);
						await new Promise(resolve => {
							requestAnimationFrame(resolve);
						});
					}
				}
			}
			
			this.isRendering = false;
			progressCallback(1);
		}

		async renderJulia(canvas, progressCallback) {
			if (this.isRendering) return;
			this.isRendering = true;
			
			const ctx = canvas.getContext('2d');
			const width = canvas.width;
			const height = canvas.height;
			
			const magnification = 200;
			const panX = 1.5;
			const panY = 1.5;
			const cRe = -0.7;
			const cIm = 0.27015;
			const iterations = 100;
			
			// Clear canvas with a subtle background
			ctx.fillStyle = '#f8f9fa';
			ctx.fillRect(0, 0, width, height);
			
			const chunkSize = 8000;
			let pixelCount = 0;
			const totalPixels = width * height;
			
			for (let x = 0; x < width; x++) {
				for (let y = 0; y < height; y++) {
					const zx = x / magnification - panX;
					const zy = y / magnification - panY;
					const belongsToSet = this.checkIfBelongsToJuliaSet(zx, zy, cRe, cIm, iterations);
					
					ctx.fillStyle = this.getJuliaColor(x, y, belongsToSet, width, height);
					ctx.fillRect(x, y, 1, 1);
					
					pixelCount++;
					
					if (pixelCount % chunkSize === 0) {
						const progress = pixelCount / totalPixels;
						progressCallback(progress);
						await new Promise(resolve => {
							requestAnimationFrame(resolve);
						});
					}
				}
			}
			
			this.isRendering = false;
			progressCallback(1);
		}

		checkIfBelongsToMandelbrotSet(x, y, iterations) {
			let realComponentOfResult = x;
			let imaginaryComponentOfResult = y;

			for (let i = 0; i < iterations; i++) {
				const tempRealComponent = realComponentOfResult * realComponentOfResult
					- imaginaryComponentOfResult * imaginaryComponentOfResult + x;
				const tempImaginaryComponent = 2 * realComponentOfResult * imaginaryComponentOfResult + y;

				realComponentOfResult = tempRealComponent;
				imaginaryComponentOfResult = tempImaginaryComponent;
				
				if (realComponentOfResult * imaginaryComponentOfResult > 99999) {
					return (i / iterations * 100);
				}
			}
			return 0;
		}

		checkIfBelongsToJuliaSet(x, y, cRe, cIm, iterations) {
			let zx = x;
			let zy = y;
			for (let i = 0; i < iterations; i++) {
				const xtemp = zx * zx - zy * zy + cRe;
				zy = 2 * zx * zy + cIm;
				zx = xtemp;
				if (zx * zx + zy * zy > 16) return (i / iterations * 100);
			}
			return 0;
		}

		getDistanceFromCenter(x, y, width, height) {
			const dx = (x - width / 2) / (width / 2);
			const dy = (y - height / 2) / (height / 2);
			return Math.sqrt(dx * dx + dy * dy);
		}

		getJuliaColor(x, y, belongsToSet, width, height) {
			const insideColor = [251, 220, 117];
			const maxAlpha = 0.95;
			const fadeStart = 0.92;
			const fadeEnd = 1.0;
			const dist = this.getDistanceFromCenter(x, y, width, height);
			
			if (belongsToSet === 0) {
				let alpha = maxAlpha;
				if (dist > fadeStart) {
					alpha *= 1 - Math.min((dist - fadeStart) / (fadeEnd - fadeStart), 1);
				}
				return `rgba(${insideColor[0]}, ${insideColor[1]}, ${insideColor[2]}, ${alpha})`;
			} else {
				const norm = Math.log(1 + belongsToSet) / Math.log(101);
				const hue = (200 + 120 * norm + 60 * Math.sin((x - y) / 90)) % 360;
				const light = 55 + 35 * Math.sin(norm * Math.PI * 2);
				let alpha = 0.45 + 0.45 * Math.pow(norm, 0.7);
				
				if (dist > fadeStart) {
					alpha *= 1 - Math.min((dist - fadeStart) / (fadeEnd - fadeStart), 1);
				}
				if (alpha < 0) alpha = 0;
				return `hsla(${hue}, 85%, ${light}%, ${alpha})`;
			}
		}
	}

	// Auto-render fractals on page load
	document.addEventListener('DOMContentLoaded', function() {
		const renderer = new FractalRenderer();
		const mandelbrotCanvas = document.getElementById('myCanvas');
		const juliaCanvas = document.getElementById('juliaCanvas');
		const mandelbrotLoader = document.getElementById('mandelbrotLoader');
		const juliaLoader = document.getElementById('juliaLoader');
		const mandelbrotProgress = document.getElementById('mandelbrotProgress');
		const juliaProgress = document.getElementById('juliaProgress');

		// Add staggered start for better UX
		setTimeout(() => {
			// Start Mandelbrot rendering
			renderer.renderMandelbrot(mandelbrotCanvas, (progress) => {
				const percentage = Math.round(progress * 100);
				mandelbrotProgress.textContent = `${percentage}% complete`;
				
				if (progress >= 1) {
					setTimeout(() => {
						mandelbrotLoader.style.opacity = '0';
						mandelbrotLoader.style.transition = 'opacity 0.5s ease';
						setTimeout(() => {
							mandelbrotLoader.style.display = 'none';
						}, 500);
					}, 200);
				}
			});
		}, 500);

		setTimeout(() => {
			// Start Julia rendering with slight delay
			renderer.renderJulia(juliaCanvas, (progress) => {
				const percentage = Math.round(progress * 100);
				juliaProgress.textContent = `${percentage}% complete`;
				
				if (progress >= 1) {
					setTimeout(() => {
						juliaLoader.style.opacity = '0';
						juliaLoader.style.transition = 'opacity 0.5s ease';
						setTimeout(() => {
							juliaLoader.style.display = 'none';
						}, 500);
					}, 200);
				}
			});
		}, 1000);
	});
	</script>
